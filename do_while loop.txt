[gpt5.py]  Execution time:   457.19 seconds poll status=completed
Below are drop-in additions that implement a .do … .while loop with these properties:
- Grammar support: .do must appear on its own statement line; .while <expr> must appear as a statement line following the block.
- Semantics: do-while (body executes once; then while condition is re-evaluated).
- Expansion approach: at .while, if the condition is true, we insert body tokens followed by another copy of the .while tokens. The inserted tokens are re-anchored to the .while SourcePos so all generated bytes (and asm) in the loop show the while line number in the listing. The loop continues until the condition becomes false.
- Anonymous labels, EQU, .if, and var assignments work naturally; variable updates in the loop body affect the next condition check because each inserted while is re-parsed after the body.
- Listing: bytes/asm produced by loop iterations are anchored to the .while line (as requested). The .do and .while source lines themselves are removed from the listing (like macros).

What you need to add:
- New tokens: DO_DIR for “.do”, WHILE_DIR for “.while” (in your token types and tokenizer).
- A minimal loop stack in Parser to match .do with .while.
- Two new grammar rules (DoDirective and WhileDirective) and small changes to Statement.
- A couple of no-op cases in ExpressionParser so .do/.while don’t produce assembly text.

1) Minimal Parser additions
Add these fields and helpers to Parser (parser.h / parser.cpp). They do not affect existing behavior.

In parser.h (or equivalent):
- Add a small stack for the last .do position (token index).
- Add an iteration guard to avoid infinite loops.
- Add helpers to push/pop and locate the current .do.

Example (non-intrusive):

// parser.h
public:
    std::vector<size_t> doStack;     // token indices of .do tokens
    int maxLoopUnroll = 100000;      // safety cap

    inline void PushDo(size_t idx) { doStack.push_back(idx); }
    inline bool HasDo() const { return !doStack.empty(); }
    inline size_t DoTop() const { return doStack.back(); }
    inline void PopDo() { doStack.pop_back(); }

Notes:
- You already have RemoveLine(SourcePos), InsertTokens(int, const std::vector<Token>&), SpliceConditional(...), etc.

2) expr_rules.cpp: add Do/While grammar and handlers
Add two new rules (near your other directives), and put them into Statement.

Just paste these blocks (search for a sensible location; they are self-contained).

// DoDirective
{
    DoDirective,
    RuleHandler{
        {
            { DoDirective, DO_DIR },
        },
        [](Parser& p, const std::vector<RuleArg>& args, int /*count*/) -> std::shared_ptr<ASTNode>
        {
            auto node = std::make_shared<ASTNode>(DoDirective, p.sourcePos);
            for (const auto& arg : args) node->add_child(arg);

            // Record this .do token index for matching .while
            // current_pos points right after the DO token; the DO token is at current_pos-1
            if (!p.inMacroDefinition) {
                if (p.current_pos == 0) {
                    p.throwError("Internal: .do token indexing error");
                }
                p.PushDo(p.current_pos - 1);

                // Remove the .do line from listing (mirror macro-call behavior)
                const Token& tok = std::get<Token>(args[0]);
                p.RemoveLine(tok.pos);
            }

            node->value = 0;
            return node;
        }
    }
},

// WhileDirective
{
    WhileDirective,
    RuleHandler{
        {
            { WhileDirective, WHILE_DIR, -Expr }
        },
        [](Parser& p, const std::vector<RuleArg>& args, int /*count*/) -> std::shared_ptr<ASTNode>
        {
            auto node = std::make_shared<ASTNode>(WhileDirective, p.sourcePos);
            for (const auto& arg : args) node->add_child(arg);

            if (p.inMacroDefinition) {
                // ignore inside macro definitions
                node->value = 0;
                return node;
            }

            if (!p.HasDo()) {
                p.throwError(".while without matching .do");
            }

            // Evaluate condition (non-zero = true)
            auto condNode = std::get<std::shared_ptr<ASTNode>>(args[1]);
            bool cond = (condNode->value != 0);
            node->value = cond ? 1 : 0;

            // Remove the .while line from listing
            const Token& whileTok = std::get<Token>(args[0]);
            SourcePos whilePos = whileTok.pos;
            p.RemoveLine(whilePos);

            // Locate the matching .do token index
            size_t doIdx = p.DoTop();

            // Find the end of the .do line (its EOL), body begins right after that EOL
            size_t doEOL = doIdx;
            while (doEOL < p.tokens.size() && p.tokens[doEOL].type != EOL) ++doEOL;
            if (doEOL >= p.tokens.size()) {
                p.throwError("Malformed .do: missing EOL");
            }
            size_t bodyStart = doEOL + 1;

            // Find the index of the current .while token
            // We are currently positioned after parsing WHILE_DIR and its expression,
            // so scan backwards to the WHILE_DIR token of THIS statement.
            size_t wIdx = p.current_pos;
            while (wIdx > 0 && p.tokens[wIdx - 1].type != WHILE_DIR) --wIdx;
            if (wIdx == 0 || p.tokens[wIdx - 1].type != WHILE_DIR) {
                p.throwError("Internal: could not find current .while token");
            }
            size_t whileIdx = wIdx - 1;

            // Body is [bodyStart, whileIdx)
            if (whileIdx < bodyStart) {
                p.throwError("Empty or invalid .do/.while block");
            }

            // Capture while line through its EOL
            size_t whileEOL = whileIdx;
            while (whileEOL < p.tokens.size() && p.tokens[whileEOL].type != EOL) ++whileEOL;
            if (whileEOL >= p.tokens.size()) {
                p.throwError("Malformed .while: missing EOL");
            }

            if (!cond) {
                // Condition false: end loop; pop the matching .do
                p.PopDo();
                return node;
            }

            // Condition true: re-insert BODY + WHILE line, both re-anchored to the while's SourcePos.
            // This naturally re-parses the body, applies var updates, and re-evaluates the while again.
            // Safety: cap unrolling
            static thread_local int guard = 0;
            if (++guard > p.maxLoopUnroll) {
                p.throwError("Loop unroll limit exceeded (possible infinite .do/.while)");
            }

            std::vector<Token> expanded;
            expanded.reserve((whileIdx - bodyStart) + (whileEOL - whileIdx + 1));

            // Copy body tokens
            for (size_t i = bodyStart; i < whileIdx; ++i) {
                Token t = p.tokens[i];
                t.pos = whilePos; // anchor to while line for listing
                expanded.push_back(std::move(t));
            }

            // Copy the while-line tokens (including EOL) so the loop can evaluate again
            for (size_t i = whileIdx; i <= whileEOL; ++i) {
                Token t = p.tokens[i];
                t.pos = whilePos; // anchor to while line
                expanded.push_back(std::move(t));
            }

            // Insert expanded tokens at current position (i.e., right where we are)
            p.InsertTokens(static_cast<int>(p.current_pos), expanded);

            // Note: doStack is intentionally NOT popped here. When the re-inserted while
            // evaluates to false, it will pop the matching .do.

            --guard;
            return node;
        }
    }
},

Now add these two to Statement alternatives (augment the existing Statement rules):

{ Statement, -DoDirective },
{ Statement, -WhileDirective },

3) ExpressionParser: ignore .do/.while for asm text emission
No changes needed for bytes, because the loop is realized by physically inserting more tokens (i.e., regular instructions are emitted as usual). But to keep the assembly-column tidy (like you did for macros and vars), skip .do/.while in generate_assembly.

Add these cases to generate_assembly’s switch:

case DoDirective:
case WhileDirective:
    return;

That’s it. The byte generator already uses node->position as the anchor. Because we set all inserted tokens’ pos to the whilePos, the byteOutput and asm lines for the loop body will be grouped under the .while line number, exactly as requested.

Notes and constraints
- Tokens: define DO_DIR for “.do” and WHILE_DIR for “.while” in your token.h/tokenizer.
- Expressions: .while uses your existing -Expr; non-zero means “true.” If you want relational operators (<, <=, ==, !=, >=, >), add a CompareExpr level between OrExpr and Expr. The loop machinery does not depend on it; it will work with any expression that resolves to a value.
- Nesting: works because we keep a stack of .do indices. The matching .do remains on the stack across expansions and is popped only when the terminating .while evaluates false.
- Listing: We remove the original .do/.while lines via RemoveLine, and all injected code lines are anchored to the while line number (by setting Token.pos) so your listing shows the iterations against the one while line.
- Safety: maxLoopUnroll prevents runaway loops if the condition never becomes false.

If you want .while-only loops (e.g., while/loop) or .repeat/.until, you can reuse this pattern: push a marker on the start directive, and splice or replicate the block at the terminating directive; always attach listing positions to the terminating directive’s SourcePos to meet the “use final control line number” requirement.