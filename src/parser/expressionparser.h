// written by Paul Baxter
#pragma once

#include <iostream>
#include <map>
#include <set>
#include <vector>
#include <iomanip>
#include <sstream>

#include "ASTNode.h"
#include "expr_rules.h"
#include "grammar_rule.h"
#include "parser.h"
#include "token.h"
#include "tokenizer.h"

/*
 ParserOptions
 Encapsulates flags and settings used by ExpressionParser during parsing
 and output generation. Fields are intentionally plain for simple copying
 and passing between components.
*/
struct ParserOptions {
    // Input source files to parse
    std::vector<std::string> files;

    // Directories searched for included files
    std::vector<std::string> includeDirectories;

    // Allow illegal constructs (best-effort parsing)
    bool allowIllegal = false;

    // Target assembly style / compatibility (e.g. Commodore 64 specifics)
    bool c64 = false;

    // Suppress warnings
    bool nowarn = false;

    // Verbose logging / diagnostics
    bool verbose = false;

    // Output filename for generated bytes/assembly
    std::string outputfile = "";

    // Use 65C02 CPU variants (enables extended opcodes/behaviour)
    bool cpu65c02 = false;

    // Print AST to stdout (for debugging)
    bool printAst = false;

    // Show all symbols when printing symbol tables
    bool showAllSymbols = false;
};

/*
 ExpressionParser
 Coordinates tokenization, grammar parsing and final assembly output.
 Responsibilities:
  - Hold parser state and options
  - Perform multi-pass assembly and listing generation
  - Produce byte output, assembly text and listing lines
  - Provide helper utilities for formatting printed bytes/addresses
*/
class ExpressionParser {
public:
    // Current loop nesting level (used by macro / loop constructs)
    int looplevel;

    // Source position for the loop output (used in listings)
    SourcePos loopOutputpos;

    // Primary parser instance used to parse expressions and statements
    std::shared_ptr<Parser> parser;

    // Secondary parser used for 'do' or nested parsing contexts
    std::shared_ptr<Parser> doParser;

    // True while inside a macro definition; suppresses certain outputs
    bool inMacrodefinition = false;

    // Top-level entry that generates output from an AST root node.
    void generate_output(std::shared_ptr<ASTNode> node);

    // Raw lines collected from input (source position, text)
    std::vector<std::pair<SourcePos, std::string>> lines;

    // Final assembled bytes produced (skips bytes created while in macros)
    std::vector<uint8_t> output_bytes;
  
    // Reset the expected program counter to the current program counter.
    // Used between passes to re-synchronize expected PC checks.
    void resetExpectedPC()  {  expected_pc = currentPC; }

private:
    // Parser options passed in by the caller
    ParserOptions options;

    // Internal printing state used during listing generation
    int printstate;

    // Whether byte output is currently allowed (some directives may disable)
    bool allowbytes = true;

    // Current source position being processed
    SourcePos pos;

    // Last processed source position
    SourcePos lastpos;

    // Current program counter (PC) while assembling
    uint16_t currentPC;

    // Expected program counter used to validate generated bytes
    uint16_t expected_pc;

    // Current filename being processed (for listings/errors)
    std::string currentfile;

    // Performs assembly over the AST and returns a new AST containing
    // assembled constructs (const because it doesn't modify parser state)
    std::shared_ptr<ASTNode> Assemble() const;

    // Listing and assembly buffers (position + text)
    std::vector<std::pair<SourcePos, std::string>> listLines;
    std::vector<std::pair<SourcePos, std::string>> byteOutput;
    std::vector<std::pair<SourcePos, std::string>> asmlines;

    // Map from source positions to print/list indices (for cross-referencing)
    std::map<SourcePos, int> printMap;

    // Build the print map from an AST for quick listing lookup
    void generate_printmap(std::shared_ptr<ASTNode> node);

    // Output generation helpers (produce the different output artifacts)
    void print_outbytes();
    void print_asm();
    void print_listfile();
    void print_printmap();

    // Extracts a list of numeric expressions (bytes/words) from an AST node
    // If 'word' is true, pushes 16-bit values; otherwise pushes 8-bit values.
    void extractExpressionList(std::shared_ptr<ASTNode>& node, std::vector<uint16_t>& data, bool word = false);

    // Formatting helpers used while building the byte/assembly listing.
    // These functions append formatted content to byteOutputLine.
    void printPC(uint16_t pc)
    {
        // Suppress printing while inside macro definitions
        if (inMacrodefinition)
            return;

        std::stringstream ss;

        ss
            << "$"
            << std::hex << std::uppercase << std::setw(4) << std::setfill('0')
            << (int)pc << ":"
            << std::dec << std::setw(0) << std::nouppercase << std::setfill(' ');

        std::string str;
        ss >> str;
        byteOutputLine += str;
    }

    // Append a single byte in formatted hex to the current byteOutputLine.
    void printbyte(uint8_t value)
    {
        if (inMacrodefinition)
            return;

        std::stringstream ss;
        ss
            << "$"
            << std::hex << std::uppercase << std::setw(2) << std::setfill('0') << static_cast<int>(value)
            << std::dec << std::nouppercase << std::setw(0) << std::setfill(' ');

        std::string str;
        ss >> str;
        byteOutputLine += paddLeft(str, 4);
    }

    // Emit a byte to the assembled output and validate PC sequencing.
    // Throws runtime_error if the expected PC does not match the current PC.
    void outputbyte(uint8_t value)
    {
        if (currentPC != expected_pc) {
            std::stringstream expected;
            std::stringstream actual;

            expected << "$" << std::hex << std::uppercase << std::setw(2) << std::setfill('0') << expected_pc;
            actual << "$" << std::hex << std::uppercase << std::setw(2) << std::setfill('0') << currentPC;
            throw std::runtime_error("Expected PC value " + expected.str() + " but got " + actual.str());
        }
        // Advance both expected and actual PC
        expected_pc++;
        currentPC++;

        // Only append to output if not inside a macro definition
        if (!inMacrodefinition) {
            output_bytes.push_back(value);
        }
    }

    // Print a 16-bit value as two little-endian bytes to the listing.
    void printword(uint16_t value)
    {
        if (inMacrodefinition)
            return;

        auto lo = (value & 0x00FF) >> 0;
        auto hi = (value & 0xFF00) >> 8;

        printbyte(lo);
        printbyte(hi);
    }

    // Working strings used while composing output lines
    std::string byteOutputLine;
    std::string asmOutputLine;
    size_t asmOutputLine_Pos;

    // Layout constants for listing generation
    const size_t instruction_indent = 4;
    const size_t byteOutputWidth = 23;
    const size_t asmLineWidth = 35;

    // Maximum number of assembly passes (used for forward references, etc.)
    const int max_passes = 7;

public:     
    // Construct parser with the given options (ownership retained by caller)
    ExpressionParser(ParserOptions& options);

    // Print the symbol table (delegates to internal parser)
    void printsymbols() const { parser->printSymbols(options.showAllSymbols); }
    
    // High-level generation functions called by the driver:
    // - generate_file_list: build internal list of source lines
    // - generate_output_bytes: produce the assembled byte vector
    // - generate_assembly: produce textual assembly listing
    // - generate_listing: produce combined listing (addresses, bytes, asm)
    void generate_file_list(std::shared_ptr<ASTNode> ast);
    void generate_output_bytes(std::shared_ptr<ASTNode> ast);
    void generate_assembly(std::shared_ptr<ASTNode>as);
    void generate_listing();

    // Parse input and return the AST root (const: does not mutate parser config)
    std::shared_ptr<ASTNode> parse() const;

    // Diagnostic/test entry for opcode/grammar dictionaries
    void TestParserDict() const;
};
