// written by Paul Baxter
//
// ASTNode.h
// Lightweight AST node used by the assembler parser.
// The node is intentionally simple and stores a numeric type tag,
// an integer value (when applicable), source locations and a vector
// of variant child arguments (see RuleArg in grammar_rule.h).
//
// Design notes:
//  - `type` is a numeric tag used by the parser/grammar rules to identify
//    the kind of node (operator, directive, literal, etc.). The mapping
//    from tag -> human-readable name is stored in the static `astMap`.
//  - `value` holds an integer payload used by many node kinds (immediates,
//    small integer results, rule-specific flags).
//  - `sourcePosition` records where this node originated in the source
//    (filename + 1-based line number). It is used for diagnostics and
//    for generating listings.
//  - `listPosition` may be used to track listing output location separately
//    from the original source position (e.g. after macro expansion).
//  - `color` is a presentation hint used by printing routines to decide
//    whether to apply ANSI color sequences.
//  - `pc_Start` holds the program counter (address) where this node's
//    generated bytes begin; 0 means unset in the default constructors.
//  - `children` stores the node's operands / subexpressions. The element
//    type `RuleArg` is typically a variant that can hold `Token`, a
//    `std::shared_ptr<ASTNode>` or other rule-specific data.
//
// The class intentionally does not manage ownership of `RuleArg` contents
// beyond what the variant type provides; memory management for child
// AST nodes is via `std::shared_ptr<ASTNode>` inside the children vector.
//
// The header exposes a small printing helper `print` and a convenience
// `add_child` method. Implementations live in `ASTNode.cpp`.
#pragma once
#include <map>
#include <memory>
#include <vector>

#include "common_types.h"
#include "token.h"

class ASTNode {
public:
    // Numeric tag identifying the node kind (see astMap for names).
    int64_t type = 0;

    // Optional integer payload for literals, flags, etc.
    int32_t value = 0;

    // Source position where this node was created (filename + 1-based line).
    SourcePos sourcePosition;

    // Source/listing position used when emitting listings (may differ from sourcePosition).
    SourcePos listPosition;

    // Presentation hint: whether to use colored output when printing.
    bool color = true;

    // Program counter at which this node's emitted bytes start (0 == unset).
    int pc_Start;

    // Node children / operands. Each element is a RuleArg (variant type).
    std::vector<RuleArg> children;

    // Static mapping from numeric `type` tags to human-readable names used by printers.
    static std::map<int64_t, std::string> astMap;

    // Default constructors provide sensible initial state. pc_Start defaults to 0.
    ASTNode() : type(0), sourcePosition({ "", 0 }), pc_Start(0) {}
    ASTNode(int64_t type) : type(type), sourcePosition({"", 0}), pc_Start(0) {}
    ASTNode(int64_t type, SourcePos pos) : type(type), sourcePosition(pos), pc_Start(0) {}
    ASTNode(int64_t type, SourcePos pos, int32_t v) : type(type), value(v), sourcePosition(pos), pc_Start(0) {}
    ASTNode(int64_t type, SourcePos pos, int32_t v, int pc) : type(type), value(v), sourcePosition(pos), pc_Start(pc) {}

    // Add a child to this node. The child object is copied into the children vector.
    void add_child(const RuleArg& child) { children.push_back(child); }

    // Print the node (and recursively its children) to the provided stream.
    // Parameters:
    //  - os: output stream
    //  - color: apply color sequences if true
    //  - indent: current indentation level
    //  - prefix: optional string printed before the node (useful for tree printers)
    //  - isLast: when printing tree glyphs, indicates whether this node is the last sibling
    void print(std::ostream& os, bool color, int indent = 0, const std::string& prefix = "", bool isLast = true) const;
};
